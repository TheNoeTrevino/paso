// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: columns.sql

package generated

import (
	"context"
)

const clearCompletedColumnByProject = `-- name: ClearCompletedColumnByProject :exec
UPDATE columns SET holds_completed_tasks = 0
WHERE project_id = ? AND holds_completed_tasks = 1
`

func (q *Queries) ClearCompletedColumnByProject(ctx context.Context, projectID int64) error {
	_, err := q.db.ExecContext(ctx, clearCompletedColumnByProject, projectID)
	return err
}

const clearReadyColumnByProject = `-- name: ClearReadyColumnByProject :exec
UPDATE columns SET holds_ready_tasks = 0
WHERE project_id = ? AND holds_ready_tasks = 1
`

func (q *Queries) ClearReadyColumnByProject(ctx context.Context, projectID int64) error {
	_, err := q.db.ExecContext(ctx, clearReadyColumnByProject, projectID)
	return err
}

const columnExists = `-- name: ColumnExists :one

SELECT COUNT(*) FROM columns WHERE id = ?
`

// ============================================================================
// COLUMN VERIFICATION
// ============================================================================
func (q *Queries) ColumnExists(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, columnExists, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createColumn = `-- name: CreateColumn :one

INSERT INTO columns (
    name, project_id, prev_id, next_id, holds_ready_tasks, holds_completed_tasks
)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, name, prev_id, next_id, project_id, holds_ready_tasks, holds_completed_tasks
`

type CreateColumnParams struct {
	Name                string
	ProjectID           int64
	PrevID              interface{}
	NextID              interface{}
	HoldsReadyTasks     bool
	HoldsCompletedTasks bool
}

// ============================================================================
// COLUMN CRUD OPERATIONS
// ============================================================================
func (q *Queries) CreateColumn(ctx context.Context, arg CreateColumnParams) (Column, error) {
	row := q.db.QueryRowContext(ctx, createColumn,
		arg.Name,
		arg.ProjectID,
		arg.PrevID,
		arg.NextID,
		arg.HoldsReadyTasks,
		arg.HoldsCompletedTasks,
	)
	var i Column
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PrevID,
		&i.NextID,
		&i.ProjectID,
		&i.HoldsReadyTasks,
		&i.HoldsCompletedTasks,
	)
	return i, err
}

const deleteColumn = `-- name: DeleteColumn :exec
DELETE FROM columns WHERE id = ?
`

func (q *Queries) DeleteColumn(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteColumn, id)
	return err
}

const deleteTasksByColumn = `-- name: DeleteTasksByColumn :exec
DELETE FROM tasks WHERE column_id = ?
`

func (q *Queries) DeleteTasksByColumn(ctx context.Context, columnID int64) error {
	_, err := q.db.ExecContext(ctx, deleteTasksByColumn, columnID)
	return err
}

const getColumnByID = `-- name: GetColumnByID :one
SELECT
    id,
name,
project_id,
prev_id,
next_id,
holds_ready_tasks,
holds_completed_tasks
FROM columns
WHERE id = ?
`

type GetColumnByIDRow struct {
	ID                  int64
	Name                string
	ProjectID           int64
	PrevID              interface{}
	NextID              interface{}
	HoldsReadyTasks     bool
	HoldsCompletedTasks bool
}

func (q *Queries) GetColumnByID(ctx context.Context, id int64) (GetColumnByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getColumnByID, id)
	var i GetColumnByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProjectID,
		&i.PrevID,
		&i.NextID,
		&i.HoldsReadyTasks,
		&i.HoldsCompletedTasks,
	)
	return i, err
}

const getColumnLinkedListInfo = `-- name: GetColumnLinkedListInfo :one
SELECT prev_id, next_id, project_id FROM columns WHERE id = ?
`

type GetColumnLinkedListInfoRow struct {
	PrevID    interface{}
	NextID    interface{}
	ProjectID int64
}

func (q *Queries) GetColumnLinkedListInfo(ctx context.Context, id int64) (GetColumnLinkedListInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getColumnLinkedListInfo, id)
	var i GetColumnLinkedListInfoRow
	err := row.Scan(&i.PrevID, &i.NextID, &i.ProjectID)
	return i, err
}

const getColumnNextID = `-- name: GetColumnNextID :one
SELECT next_id FROM columns WHERE id = ?
`

func (q *Queries) GetColumnNextID(ctx context.Context, id int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getColumnNextID, id)
	var next_id interface{}
	err := row.Scan(&next_id)
	return next_id, err
}

const getColumnsByProject = `-- name: GetColumnsByProject :many
SELECT id,
name,
project_id,
prev_id,
next_id,
holds_ready_tasks,
holds_completed_tasks
FROM columns
WHERE project_id = ?
`

type GetColumnsByProjectRow struct {
	ID                  int64
	Name                string
	ProjectID           int64
	PrevID              interface{}
	NextID              interface{}
	HoldsReadyTasks     bool
	HoldsCompletedTasks bool
}

func (q *Queries) GetColumnsByProject(ctx context.Context, projectID int64) ([]GetColumnsByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getColumnsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetColumnsByProjectRow{}
	for rows.Next() {
		var i GetColumnsByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ProjectID,
			&i.PrevID,
			&i.NextID,
			&i.HoldsReadyTasks,
			&i.HoldsCompletedTasks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompletedColumnByProject = `-- name: GetCompletedColumnByProject :one
SELECT id, name, project_id, prev_id, next_id, holds_completed_tasks
FROM columns
WHERE project_id = ? AND holds_completed_tasks = 1
LIMIT 1
`

type GetCompletedColumnByProjectRow struct {
	ID                  int64
	Name                string
	ProjectID           int64
	PrevID              interface{}
	NextID              interface{}
	HoldsCompletedTasks bool
}

func (q *Queries) GetCompletedColumnByProject(ctx context.Context, projectID int64) (GetCompletedColumnByProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getCompletedColumnByProject, projectID)
	var i GetCompletedColumnByProjectRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProjectID,
		&i.PrevID,
		&i.NextID,
		&i.HoldsCompletedTasks,
	)
	return i, err
}

const getReadyColumnByProject = `-- name: GetReadyColumnByProject :one
SELECT id, name, project_id, prev_id, next_id, holds_ready_tasks
FROM columns
WHERE project_id = ? AND holds_ready_tasks = 1
LIMIT 1
`

type GetReadyColumnByProjectRow struct {
	ID              int64
	Name            string
	ProjectID       int64
	PrevID          interface{}
	NextID          interface{}
	HoldsReadyTasks bool
}

func (q *Queries) GetReadyColumnByProject(ctx context.Context, projectID int64) (GetReadyColumnByProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getReadyColumnByProject, projectID)
	var i GetReadyColumnByProjectRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProjectID,
		&i.PrevID,
		&i.NextID,
		&i.HoldsReadyTasks,
	)
	return i, err
}

const getTailColumnForProject = `-- name: GetTailColumnForProject :one
SELECT id FROM columns
WHERE next_id IS NULL AND project_id = ?
LIMIT 1
`

func (q *Queries) GetTailColumnForProject(ctx context.Context, projectID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTailColumnForProject, projectID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateColumnHoldsCompletedTasks = `-- name: UpdateColumnHoldsCompletedTasks :exec

UPDATE columns SET holds_completed_tasks = ? WHERE id = ?
`

type UpdateColumnHoldsCompletedTasksParams struct {
	HoldsCompletedTasks bool
	ID                  int64
}

// ============================================================================
// COMPLETED COLUMN OPERATIONS
// ============================================================================
func (q *Queries) UpdateColumnHoldsCompletedTasks(ctx context.Context, arg UpdateColumnHoldsCompletedTasksParams) error {
	_, err := q.db.ExecContext(ctx, updateColumnHoldsCompletedTasks, arg.HoldsCompletedTasks, arg.ID)
	return err
}

const updateColumnHoldsReadyTasks = `-- name: UpdateColumnHoldsReadyTasks :exec

UPDATE columns SET holds_ready_tasks = ? WHERE id = ?
`

type UpdateColumnHoldsReadyTasksParams struct {
	HoldsReadyTasks bool
	ID              int64
}

// ============================================================================
// READY COLUMN OPERATIONS
// ============================================================================
func (q *Queries) UpdateColumnHoldsReadyTasks(ctx context.Context, arg UpdateColumnHoldsReadyTasksParams) error {
	_, err := q.db.ExecContext(ctx, updateColumnHoldsReadyTasks, arg.HoldsReadyTasks, arg.ID)
	return err
}

const updateColumnName = `-- name: UpdateColumnName :exec
UPDATE columns SET name = ? WHERE id = ?
`

type UpdateColumnNameParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdateColumnName(ctx context.Context, arg UpdateColumnNameParams) error {
	_, err := q.db.ExecContext(ctx, updateColumnName, arg.Name, arg.ID)
	return err
}

const updateColumnNextID = `-- name: UpdateColumnNextID :exec
UPDATE columns SET next_id = ? WHERE id = ?
`

type UpdateColumnNextIDParams struct {
	NextID interface{}
	ID     int64
}

func (q *Queries) UpdateColumnNextID(ctx context.Context, arg UpdateColumnNextIDParams) error {
	_, err := q.db.ExecContext(ctx, updateColumnNextID, arg.NextID, arg.ID)
	return err
}

const updateColumnPrevID = `-- name: UpdateColumnPrevID :exec
UPDATE columns SET prev_id = ? WHERE id = ?
`

type UpdateColumnPrevIDParams struct {
	PrevID interface{}
	ID     int64
}

func (q *Queries) UpdateColumnPrevID(ctx context.Context, arg UpdateColumnPrevIDParams) error {
	_, err := q.db.ExecContext(ctx, updateColumnPrevID, arg.PrevID, arg.ID)
	return err
}
