// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: columns.sql

package generated

import (
	"context"
)

const clearCompletedColumnByProject = `-- name: ClearCompletedColumnByProject :exec
update columns
set holds_completed_tasks = 0
where project_id = ?
and holds_completed_tasks = 1
`

// Clears the completed task flag from all columns in a project
func (q *Queries) ClearCompletedColumnByProject(ctx context.Context, projectID int64) error {
	_, err := q.db.ExecContext(ctx, clearCompletedColumnByProject, projectID)
	return err
}

const clearInProgressColumnByProject = `-- name: ClearInProgressColumnByProject :exec
update columns
set holds_in_progress_tasks = 0
where project_id = ?
and holds_in_progress_tasks = 1
`

// Clears the in-progress task flag from all columns in a project
func (q *Queries) ClearInProgressColumnByProject(ctx context.Context, projectID int64) error {
	_, err := q.db.ExecContext(ctx, clearInProgressColumnByProject, projectID)
	return err
}

const clearReadyColumnByProject = `-- name: ClearReadyColumnByProject :exec
update columns
set holds_ready_tasks = 0
where project_id = ?
and holds_ready_tasks = 1
`

// Clears the ready task flag from all columns in a project
func (q *Queries) ClearReadyColumnByProject(ctx context.Context, projectID int64) error {
	_, err := q.db.ExecContext(ctx, clearReadyColumnByProject, projectID)
	return err
}

const columnExists = `-- name: ColumnExists :one
select count(*)
from columns
where id = ?
`

// Checks if a column exists with the given ID
func (q *Queries) ColumnExists(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, columnExists, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createColumn = `-- name: CreateColumn :one
insert into columns (
    name,
    project_id,
    prev_id,
    next_id,
    holds_ready_tasks,
    holds_completed_tasks,
    holds_in_progress_tasks
)
values (?, ?, ?, ?, ?, ?, ?)
returning id, name, prev_id, next_id, project_id, holds_ready_tasks, holds_completed_tasks, holds_in_progress_tasks
`

type CreateColumnParams struct {
	Name                 string
	ProjectID            int64
	PrevID               interface{}
	NextID               interface{}
	HoldsReadyTasks      bool
	HoldsCompletedTasks  bool
	HoldsInProgressTasks bool
}

// Creates a new column in a project with optional
// linked list positioning and task type flags
func (q *Queries) CreateColumn(ctx context.Context, arg CreateColumnParams) (Column, error) {
	row := q.db.QueryRowContext(ctx, createColumn,
		arg.Name,
		arg.ProjectID,
		arg.PrevID,
		arg.NextID,
		arg.HoldsReadyTasks,
		arg.HoldsCompletedTasks,
		arg.HoldsInProgressTasks,
	)
	var i Column
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PrevID,
		&i.NextID,
		&i.ProjectID,
		&i.HoldsReadyTasks,
		&i.HoldsCompletedTasks,
		&i.HoldsInProgressTasks,
	)
	return i, err
}

const deleteColumn = `-- name: DeleteColumn :exec
delete from columns
where id = ?
`

// Permanently deletes a column by ID
func (q *Queries) DeleteColumn(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteColumn, id)
	return err
}

const deleteTasksByColumn = `-- name: DeleteTasksByColumn :exec
delete from tasks
where column_id = ?
`

// Deletes all tasks within a specific column
func (q *Queries) DeleteTasksByColumn(ctx context.Context, columnID int64) error {
	_, err := q.db.ExecContext(ctx, deleteTasksByColumn, columnID)
	return err
}

const getColumnByID = `-- name: GetColumnByID :one
select
    id,
    name,
    project_id,
    prev_id,
    next_id,
    holds_ready_tasks,
    holds_completed_tasks,
    holds_in_progress_tasks
from columns
where id = ?
`

type GetColumnByIDRow struct {
	ID                   int64
	Name                 string
	ProjectID            int64
	PrevID               interface{}
	NextID               interface{}
	HoldsReadyTasks      bool
	HoldsCompletedTasks  bool
	HoldsInProgressTasks bool
}

// Retrieves a column by its ID with all metadata
func (q *Queries) GetColumnByID(ctx context.Context, id int64) (GetColumnByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getColumnByID, id)
	var i GetColumnByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProjectID,
		&i.PrevID,
		&i.NextID,
		&i.HoldsReadyTasks,
		&i.HoldsCompletedTasks,
		&i.HoldsInProgressTasks,
	)
	return i, err
}

const getColumnLinkedListInfo = `-- name: GetColumnLinkedListInfo :one
select 
    prev_id,
    next_id,
    project_id
from columns
where id = ?
`

type GetColumnLinkedListInfoRow struct {
	PrevID    interface{}
	NextID    interface{}
	ProjectID int64
}

// Retrieves the linked list pointers and project ID for a column
func (q *Queries) GetColumnLinkedListInfo(ctx context.Context, id int64) (GetColumnLinkedListInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getColumnLinkedListInfo, id)
	var i GetColumnLinkedListInfoRow
	err := row.Scan(&i.PrevID, &i.NextID, &i.ProjectID)
	return i, err
}

const getColumnNextID = `-- name: GetColumnNextID :one
select next_id 
from columns
where id = ?
`

// Retrieves the next column ID in the linked list
func (q *Queries) GetColumnNextID(ctx context.Context, id int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getColumnNextID, id)
	var next_id interface{}
	err := row.Scan(&next_id)
	return next_id, err
}

const getColumnsByProject = `-- name: GetColumnsByProject :many
select
    id,
    name,
    project_id,
    prev_id,
    next_id,
    holds_ready_tasks,
    holds_completed_tasks,
    holds_in_progress_tasks
from columns
where project_id = ?
`

type GetColumnsByProjectRow struct {
	ID                   int64
	Name                 string
	ProjectID            int64
	PrevID               interface{}
	NextID               interface{}
	HoldsReadyTasks      bool
	HoldsCompletedTasks  bool
	HoldsInProgressTasks bool
}

// Retrieves all columns for a specific project
func (q *Queries) GetColumnsByProject(ctx context.Context, projectID int64) ([]GetColumnsByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getColumnsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetColumnsByProjectRow{}
	for rows.Next() {
		var i GetColumnsByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ProjectID,
			&i.PrevID,
			&i.NextID,
			&i.HoldsReadyTasks,
			&i.HoldsCompletedTasks,
			&i.HoldsInProgressTasks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompletedColumnByProject = `-- name: GetCompletedColumnByProject :one
select
    id,
    name,
    project_id,
    prev_id,
    next_id,
    holds_completed_tasks
from columns
where project_id = ? and holds_completed_tasks = 1
limit 1
`

type GetCompletedColumnByProjectRow struct {
	ID                  int64
	Name                string
	ProjectID           int64
	PrevID              interface{}
	NextID              interface{}
	HoldsCompletedTasks bool
}

// Retrieves the column designated for completed tasks in a project
func (q *Queries) GetCompletedColumnByProject(ctx context.Context, projectID int64) (GetCompletedColumnByProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getCompletedColumnByProject, projectID)
	var i GetCompletedColumnByProjectRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProjectID,
		&i.PrevID,
		&i.NextID,
		&i.HoldsCompletedTasks,
	)
	return i, err
}

const getInProgressColumnByProject = `-- name: GetInProgressColumnByProject :one
select
    id,
    name,
    project_id,
    prev_id,
    next_id,
    holds_in_progress_tasks
from columns
where project_id = ? and holds_in_progress_tasks = 1
limit 1
`

type GetInProgressColumnByProjectRow struct {
	ID                   int64
	Name                 string
	ProjectID            int64
	PrevID               interface{}
	NextID               interface{}
	HoldsInProgressTasks bool
}

// Retrieves the column designated for in-progress tasks in a project
func (q *Queries) GetInProgressColumnByProject(ctx context.Context, projectID int64) (GetInProgressColumnByProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getInProgressColumnByProject, projectID)
	var i GetInProgressColumnByProjectRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProjectID,
		&i.PrevID,
		&i.NextID,
		&i.HoldsInProgressTasks,
	)
	return i, err
}

const getReadyColumnByProject = `-- name: GetReadyColumnByProject :one
select
    id,
    name,
    project_id,
    prev_id,
    next_id,
    holds_ready_tasks
from columns
where project_id = ? and holds_ready_tasks = 1
limit 1
`

type GetReadyColumnByProjectRow struct {
	ID              int64
	Name            string
	ProjectID       int64
	PrevID          interface{}
	NextID          interface{}
	HoldsReadyTasks bool
}

// Retrieves the column designated for ready tasks in a project
func (q *Queries) GetReadyColumnByProject(ctx context.Context, projectID int64) (GetReadyColumnByProjectRow, error) {
	row := q.db.QueryRowContext(ctx, getReadyColumnByProject, projectID)
	var i GetReadyColumnByProjectRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProjectID,
		&i.PrevID,
		&i.NextID,
		&i.HoldsReadyTasks,
	)
	return i, err
}

const getTailColumnForProject = `-- name: GetTailColumnForProject :one
select id
from columns
where next_id is null
    and project_id = ?
limit 1
`

// Retrieves the last column in a project's linked list (where next_id is NULL)
func (q *Queries) GetTailColumnForProject(ctx context.Context, projectID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTailColumnForProject, projectID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateColumnHoldsCompletedTasks = `-- name: UpdateColumnHoldsCompletedTasks :exec
update columns
set holds_completed_tasks = ?
where id = ?
`

type UpdateColumnHoldsCompletedTasksParams struct {
	HoldsCompletedTasks bool
	ID                  int64
}

// Sets whether a column holds completed tasks
func (q *Queries) UpdateColumnHoldsCompletedTasks(ctx context.Context, arg UpdateColumnHoldsCompletedTasksParams) error {
	_, err := q.db.ExecContext(ctx, updateColumnHoldsCompletedTasks, arg.HoldsCompletedTasks, arg.ID)
	return err
}

const updateColumnHoldsInProgressTasks = `-- name: UpdateColumnHoldsInProgressTasks :exec
update columns
set holds_in_progress_tasks = ?
where id = ?
`

type UpdateColumnHoldsInProgressTasksParams struct {
	HoldsInProgressTasks bool
	ID                   int64
}

// Sets whether a column holds in-progress tasks
func (q *Queries) UpdateColumnHoldsInProgressTasks(ctx context.Context, arg UpdateColumnHoldsInProgressTasksParams) error {
	_, err := q.db.ExecContext(ctx, updateColumnHoldsInProgressTasks, arg.HoldsInProgressTasks, arg.ID)
	return err
}

const updateColumnHoldsReadyTasks = `-- name: UpdateColumnHoldsReadyTasks :exec
update columns
set holds_ready_tasks = ?
where id = ?
`

type UpdateColumnHoldsReadyTasksParams struct {
	HoldsReadyTasks bool
	ID              int64
}

// Sets whether a column holds ready tasks (tasks without blockers)
func (q *Queries) UpdateColumnHoldsReadyTasks(ctx context.Context, arg UpdateColumnHoldsReadyTasksParams) error {
	_, err := q.db.ExecContext(ctx, updateColumnHoldsReadyTasks, arg.HoldsReadyTasks, arg.ID)
	return err
}

const updateColumnName = `-- name: UpdateColumnName :exec
update columns
set name = ?
where id = ?
`

type UpdateColumnNameParams struct {
	Name string
	ID   int64
}

// Updates a column's display name
func (q *Queries) UpdateColumnName(ctx context.Context, arg UpdateColumnNameParams) error {
	_, err := q.db.ExecContext(ctx, updateColumnName, arg.Name, arg.ID)
	return err
}

const updateColumnNextID = `-- name: UpdateColumnNextID :exec
update columns
set next_id = ?
where id = ?
`

type UpdateColumnNextIDParams struct {
	NextID interface{}
	ID     int64
}

// Updates the next column pointer in the linked list
func (q *Queries) UpdateColumnNextID(ctx context.Context, arg UpdateColumnNextIDParams) error {
	_, err := q.db.ExecContext(ctx, updateColumnNextID, arg.NextID, arg.ID)
	return err
}

const updateColumnPrevID = `-- name: UpdateColumnPrevID :exec
update columns
set prev_id = ?
where id = ?
`

type UpdateColumnPrevIDParams struct {
	PrevID interface{}
	ID     int64
}

// Updates the previous column pointer in the linked list
func (q *Queries) UpdateColumnPrevID(ctx context.Context, arg UpdateColumnPrevIDParams) error {
	_, err := q.db.ExecContext(ctx, updateColumnPrevID, arg.PrevID, arg.ID)
	return err
}
