// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tasks.sql

package generated

import (
	"context"
	"database/sql"
)

const addSubtask = `-- name: AddSubtask :exec
insert or ignore into
task_subtasks (parent_id, child_id)
values (?, ?)
`

type AddSubtaskParams struct {
	ParentID int64
	ChildID  int64
}

// Creates a parent-child relationship between two tasks (ignores duplicates)
func (q *Queries) AddSubtask(ctx context.Context, arg AddSubtaskParams) error {
	_, err := q.db.ExecContext(ctx, addSubtask, arg.ParentID, arg.ChildID)
	return err
}

const addSubtaskWithRelationType = `-- name: AddSubtaskWithRelationType :exec
insert or replace into task_subtasks (parent_id, child_id, relation_type_id)
values (?, ?, ?)
`

type AddSubtaskWithRelationTypeParams struct {
	ParentID       int64
	ChildID        int64
	RelationTypeID int64
}

// Creates or updates a parent-child relationship with a specific relation type
func (q *Queries) AddSubtaskWithRelationType(ctx context.Context, arg AddSubtaskWithRelationTypeParams) error {
	_, err := q.db.ExecContext(ctx, addSubtaskWithRelationType, arg.ParentID, arg.ChildID, arg.RelationTypeID)
	return err
}

const createTask = `-- name: CreateTask :one
insert into tasks (
    title,
    description,
    column_id,
    position,
    ticket_number)
values (?, ?, ?, ?, ?)
returning id, title, description, column_id, position, ticket_number, type_id, priority_id, created_at, updated_at
`

type CreateTaskParams struct {
	Title        string
	Description  sql.NullString
	ColumnID     int64
	Position     int64
	TicketNumber sql.NullInt64
}

// Creates a new task with title, description, position, and ticket number
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.Title,
		arg.Description,
		arg.ColumnID,
		arg.Position,
		arg.TicketNumber,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ColumnID,
		&i.Position,
		&i.TicketNumber,
		&i.TypeID,
		&i.PriorityID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTask = `-- name: DeleteTask :exec
delete from tasks
where id = ?
`

// Permanently deletes a task by ID
func (q *Queries) DeleteTask(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTask, id)
	return err
}

const getAllPriorities = `-- name: GetAllPriorities :many
select id, description, color from priorities order by id
`

// Retrieves all available priority levels
func (q *Queries) GetAllPriorities(ctx context.Context) ([]Priority, error) {
	rows, err := q.db.QueryContext(ctx, getAllPriorities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Priority{}
	for rows.Next() {
		var i Priority
		if err := rows.Scan(&i.ID, &i.Description, &i.Color); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRelationTypes = `-- name: GetAllRelationTypes :many
select id, p_to_c_label, c_to_p_label, color, is_blocking
from relation_types
order by id
`

// Retrieves all available relationship types for task links
func (q *Queries) GetAllRelationTypes(ctx context.Context) ([]RelationType, error) {
	rows, err := q.db.QueryContext(ctx, getAllRelationTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RelationType{}
	for rows.Next() {
		var i RelationType
		if err := rows.Scan(
			&i.ID,
			&i.PToCLabel,
			&i.CToPLabel,
			&i.Color,
			&i.IsBlocking,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTypes = `-- name: GetAllTypes :many
select id, description from types order by id
`

// Retrieves all available task types
func (q *Queries) GetAllTypes(ctx context.Context) ([]Type, error) {
	rows, err := q.db.QueryContext(ctx, getAllTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Type{}
	for rows.Next() {
		var i Type
		if err := rows.Scan(&i.ID, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChildTasks = `-- name: GetChildTasks :many
select t.id, t.ticket_number, t.title, p.name,
rt.id, rt.c_to_p_label, rt.color, rt.is_blocking
from tasks t
inner join task_subtasks ts on t.id = ts.child_id
inner join relation_types rt on ts.relation_type_id = rt.id
inner join columns c on t.column_id = c.id
inner join projects p on c.project_id = p.id
where ts.parent_id = ?
order by p.name, t.ticket_number
`

type GetChildTasksRow struct {
	ID           int64
	TicketNumber sql.NullInt64
	Title        string
	Name         string
	ID_2         int64
	CToPLabel    string
	Color        string
	IsBlocking   bool
}

// Retrieves all child tasks for a given parent task with relationship details
func (q *Queries) GetChildTasks(ctx context.Context, parentID int64) ([]GetChildTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, getChildTasks, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChildTasksRow{}
	for rows.Next() {
		var i GetChildTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketNumber,
			&i.Title,
			&i.Name,
			&i.ID_2,
			&i.CToPLabel,
			&i.Color,
			&i.IsBlocking,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInProgressTaskDetails = `-- name: GetInProgressTaskDetails :many
select
    t.id,
    t.ticket_number,
    t.title,
    t.description,
    t.column_id,
    t.position,
    t.created_at,
    t.updated_at,
    c.name as column_name,
    proj.name as project_name,
    ty.description as type_description,
    p.description as priority_description,
    p.color as priority_color,
    cast(coalesce(group_concat(l.id, char(31)), '') as text) as label_ids,
    cast(coalesce(group_concat(l.name, char(31)), '') as text) as label_names,
    cast(coalesce(group_concat(l.color, char(31)), '') as text) as label_colors,
    exists(
        select 1
        from task_subtasks ts
        inner join relation_types rt on ts.relation_type_id = rt.id
        where ts.parent_id = t.id and rt.is_blocking = 1
    ) as is_blocked
from tasks t
inner join columns c on t.column_id = c.id
inner join projects proj on c.project_id = proj.id
left join types ty on t.type_id = ty.id
left join priorities p on t.priority_id = p.id
left join task_labels tl on t.id = tl.task_id
left join labels l on tl.label_id = l.id
where proj.id = ? and c.holds_in_progress_tasks = 1
group by
    t.id,
    t.ticket_number,
    t.title,
    t.description,
    t.column_id,
    t.position,
    t.created_at,
    t.updated_at,
    c.name,
    proj.name,
    ty.description,
    p.description,
    p.color
order by t.position
`

type GetInProgressTaskDetailsRow struct {
	ID                  int64
	TicketNumber        sql.NullInt64
	Title               string
	Description         sql.NullString
	ColumnID            int64
	Position            int64
	CreatedAt           sql.NullTime
	UpdatedAt           sql.NullTime
	ColumnName          string
	ProjectName         string
	TypeDescription     sql.NullString
	PriorityDescription sql.NullString
	PriorityColor       sql.NullString
	LabelIds            string
	LabelNames          string
	LabelColors         string
	IsBlocked           int64
}

// Retrieves comprehensive details for all in-progress tasks using GROUP_CONCAT to avoid N+1 queries
func (q *Queries) GetInProgressTaskDetails(ctx context.Context, id int64) ([]GetInProgressTaskDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getInProgressTaskDetails, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInProgressTaskDetailsRow{}
	for rows.Next() {
		var i GetInProgressTaskDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketNumber,
			&i.Title,
			&i.Description,
			&i.ColumnID,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ColumnName,
			&i.ProjectName,
			&i.TypeDescription,
			&i.PriorityDescription,
			&i.PriorityColor,
			&i.LabelIds,
			&i.LabelNames,
			&i.LabelColors,
			&i.IsBlocked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInProgressTasksByProject = `-- name: GetInProgressTasksByProject :many
select
    t.id,
    t.ticket_number,
    t.title,
    t.description,
    c.name as column_name,
    proj.name as project_name
from tasks t
inner join columns c on t.column_id = c.id
inner join projects proj on c.project_id = proj.id
where proj.id = ? and c.holds_in_progress_tasks = 1
order by t.position
`

type GetInProgressTasksByProjectRow struct {
	ID           int64
	TicketNumber sql.NullInt64
	Title        string
	Description  sql.NullString
	ColumnName   string
	ProjectName  string
}

// Retrieves basic information for tasks currently in progress for a project
func (q *Queries) GetInProgressTasksByProject(ctx context.Context, id int64) ([]GetInProgressTasksByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getInProgressTasksByProject, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInProgressTasksByProjectRow{}
	for rows.Next() {
		var i GetInProgressTasksByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketNumber,
			&i.Title,
			&i.Description,
			&i.ColumnName,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextColumnID = `-- name: GetNextColumnID :one
select next_id
from columns where id = ?
`

// Retrieves the ID of the next column in the linked list
func (q *Queries) GetNextColumnID(ctx context.Context, id int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getNextColumnID, id)
	var next_id interface{}
	err := row.Scan(&next_id)
	return next_id, err
}

const getNextTicketNumber = `-- name: GetNextTicketNumber :one
select next_ticket_number
from project_counters where project_id = ?
`

// Retrieves the next available ticket number for a project
func (q *Queries) GetNextTicketNumber(ctx context.Context, projectID int64) (sql.NullInt64, error) {
	row := q.db.QueryRowContext(ctx, getNextTicketNumber, projectID)
	var next_ticket_number sql.NullInt64
	err := row.Scan(&next_ticket_number)
	return next_ticket_number, err
}

const getParentTasks = `-- name: GetParentTasks :many
select t.id, t.ticket_number, t.title, p.name,
rt.id, rt.p_to_c_label, rt.color, rt.is_blocking
from tasks t
inner join task_subtasks ts on t.id = ts.parent_id
inner join relation_types rt on ts.relation_type_id = rt.id
inner join columns c on t.column_id = c.id
inner join projects p on c.project_id = p.id
where ts.child_id = ?
order by p.name, t.ticket_number
`

type GetParentTasksRow struct {
	ID           int64
	TicketNumber sql.NullInt64
	Title        string
	Name         string
	ID_2         int64
	PToCLabel    string
	Color        string
	IsBlocking   bool
}

// Retrieves all parent tasks for a given child task with relationship details
func (q *Queries) GetParentTasks(ctx context.Context, childID int64) ([]GetParentTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, getParentTasks, childID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetParentTasksRow{}
	for rows.Next() {
		var i GetParentTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketNumber,
			&i.Title,
			&i.Name,
			&i.ID_2,
			&i.PToCLabel,
			&i.Color,
			&i.IsBlocking,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrevColumnID = `-- name: GetPrevColumnID :one
select prev_id from columns where id = ?
`

// Retrieves the ID of the previous column in the linked list
func (q *Queries) GetPrevColumnID(ctx context.Context, id int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getPrevColumnID, id)
	var prev_id interface{}
	err := row.Scan(&prev_id)
	return prev_id, err
}

const getProjectIDFromColumn = `-- name: GetProjectIDFromColumn :one
select project_id
from columns where id = ?
`

// Retrieves the project ID for a given column
func (q *Queries) GetProjectIDFromColumn(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getProjectIDFromColumn, id)
	var project_id int64
	err := row.Scan(&project_id)
	return project_id, err
}

const getProjectIDFromTask = `-- name: GetProjectIDFromTask :one
select c.project_id
from tasks t
inner join columns c on t.column_id = c.id
where t.id = ?
`

// Retrieves the project ID for a given task by joining through its column
func (q *Queries) GetProjectIDFromTask(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getProjectIDFromTask, id)
	var project_id int64
	err := row.Scan(&project_id)
	return project_id, err
}

const getReadyTaskSummariesByProject = `-- name: GetReadyTaskSummariesByProject :many
select
    t.id,
    t.title,
    t.column_id,
    t.position,
    ty.description as type_description,
    p.description as priority_description,
    p.color as priority_color,
    cast(coalesce(group_concat(l.id, char(31)), '') as text) as label_ids,
    cast(coalesce(group_concat(l.name, char(31)), '') as text) as label_names,
    cast(coalesce(group_concat(l.color, char(31)), '') as text) as label_colors,
    exists(
        select 1
        from task_subtasks ts
        inner join relation_types rt on ts.relation_type_id = rt.id
        where ts.parent_id = t.id and rt.is_blocking = 1
    ) as is_blocked
from tasks t
inner join columns c on t.column_id = c.id
left join types ty on t.type_id = ty.id
left join priorities p on t.priority_id = p.id
left join task_labels tl on t.id = tl.task_id
left join labels l on tl.label_id = l.id
where c.project_id = ? and c.holds_ready_tasks = 1
group by
    t.id,
    t.title,
    t.column_id,
    t.position,
    ty.description,
    p.description,
    p.color
order by t.position
`

type GetReadyTaskSummariesByProjectRow struct {
	ID                  int64
	Title               string
	ColumnID            int64
	Position            int64
	TypeDescription     sql.NullString
	PriorityDescription sql.NullString
	PriorityColor       sql.NullString
	LabelIds            string
	LabelNames          string
	LabelColors         string
	IsBlocked           int64
}

// Retrieves task summaries for ready tasks (tasks in columns marked as holds_ready_tasks)
func (q *Queries) GetReadyTaskSummariesByProject(ctx context.Context, projectID int64) ([]GetReadyTaskSummariesByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getReadyTaskSummariesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReadyTaskSummariesByProjectRow{}
	for rows.Next() {
		var i GetReadyTaskSummariesByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ColumnID,
			&i.Position,
			&i.TypeDescription,
			&i.PriorityDescription,
			&i.PriorityColor,
			&i.LabelIds,
			&i.LabelNames,
			&i.LabelColors,
			&i.IsBlocked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTask = `-- name: GetTask :one
select
    id,
    title,
    description,
    column_id,
    position,
    created_at,
    updated_at
from tasks
where id = ?
`

type GetTaskRow struct {
	ID          int64
	Title       string
	Description sql.NullString
	ColumnID    int64
	Position    int64
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

// Retrieves basic task information by ID
func (q *Queries) GetTask(ctx context.Context, id int64) (GetTaskRow, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i GetTaskRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ColumnID,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTaskAbove = `-- name: GetTaskAbove :one
select id, position 
from tasks
where column_id = ? and position < ?
order by position desc limit 1
`

type GetTaskAboveParams struct {
	ColumnID int64
	Position int64
}

type GetTaskAboveRow struct {
	ID       int64
	Position int64
}

// Retrieves the task immediately above the given position in a column
func (q *Queries) GetTaskAbove(ctx context.Context, arg GetTaskAboveParams) (GetTaskAboveRow, error) {
	row := q.db.QueryRowContext(ctx, getTaskAbove, arg.ColumnID, arg.Position)
	var i GetTaskAboveRow
	err := row.Scan(&i.ID, &i.Position)
	return i, err
}

const getTaskBelow = `-- name: GetTaskBelow :one
select id, position 
from tasks
where column_id = ? and position > ?
order by position asc limit 1
`

type GetTaskBelowParams struct {
	ColumnID int64
	Position int64
}

type GetTaskBelowRow struct {
	ID       int64
	Position int64
}

// Retrieves the task immediately below the given position in a column
func (q *Queries) GetTaskBelow(ctx context.Context, arg GetTaskBelowParams) (GetTaskBelowRow, error) {
	row := q.db.QueryRowContext(ctx, getTaskBelow, arg.ColumnID, arg.Position)
	var i GetTaskBelowRow
	err := row.Scan(&i.ID, &i.Position)
	return i, err
}

const getTaskCountByColumn = `-- name: GetTaskCountByColumn :one
select count(*)
from tasks where column_id = ?
`

// Returns the number of tasks in a specific column
func (q *Queries) GetTaskCountByColumn(ctx context.Context, columnID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTaskCountByColumn, columnID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTaskDetail = `-- name: GetTaskDetail :one
select
    t.id,
    t.title,
    t.description,
    t.column_id,
    t.position,
    t.ticket_number,
    t.created_at,
    t.updated_at,
    ty.description as type_description,
    p.description as priority_description,
    p.color as priority_color,
    c.name as column_name,
    proj.name as project_name,
    exists(
        select 1 from task_subtasks ts
        inner join relation_types rt on ts.relation_type_id = rt.id
        where ts.parent_id = t.id and rt.is_blocking = 1
    ) as is_blocked
from tasks t
inner join columns c on t.column_id = c.id
inner join projects proj on c.project_id = proj.id
left join types ty on t.type_id = ty.id
left join priorities p on t.priority_id = p.id
where t.id = ?
`

type GetTaskDetailRow struct {
	ID                  int64
	Title               string
	Description         sql.NullString
	ColumnID            int64
	Position            int64
	TicketNumber        sql.NullInt64
	CreatedAt           sql.NullTime
	UpdatedAt           sql.NullTime
	TypeDescription     sql.NullString
	PriorityDescription sql.NullString
	PriorityColor       sql.NullString
	ColumnName          string
	ProjectName         string
	IsBlocked           int64
}

// Retrieves comprehensive task details including:
// type, priority, column, project, and blocking status
func (q *Queries) GetTaskDetail(ctx context.Context, id int64) (GetTaskDetailRow, error) {
	row := q.db.QueryRowContext(ctx, getTaskDetail, id)
	var i GetTaskDetailRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ColumnID,
		&i.Position,
		&i.TicketNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TypeDescription,
		&i.PriorityDescription,
		&i.PriorityColor,
		&i.ColumnName,
		&i.ProjectName,
		&i.IsBlocked,
	)
	return i, err
}

const getTaskLabels = `-- name: GetTaskLabels :many
select l.id, l.name, l.color, l.project_id
from labels l
inner join task_labels tl on l.id = tl.label_id
where tl.task_id = ?
order by l.name
`

// Retrieves all labels attached to a specific task
func (q *Queries) GetTaskLabels(ctx context.Context, taskID int64) ([]Label, error) {
	rows, err := q.db.QueryContext(ctx, getTaskLabels, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Label{}
	for rows.Next() {
		var i Label
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskPosition = `-- name: GetTaskPosition :one
select column_id, position
from tasks
where id = ?
`

type GetTaskPositionRow struct {
	ColumnID int64
	Position int64
}

// Retrieves the current column and position of a task
func (q *Queries) GetTaskPosition(ctx context.Context, id int64) (GetTaskPositionRow, error) {
	row := q.db.QueryRowContext(ctx, getTaskPosition, id)
	var i GetTaskPositionRow
	err := row.Scan(&i.ColumnID, &i.Position)
	return i, err
}

const getTaskReferencesForProject = `-- name: GetTaskReferencesForProject :many
select t.id, t.ticket_number, t.title, p.name
from tasks t
inner join columns c on t.column_id = c.id
inner join projects p on c.project_id = p.id
where p.id = ?
order by p.name, t.ticket_number
`

type GetTaskReferencesForProjectRow struct {
	ID           int64
	TicketNumber sql.NullInt64
	Title        string
	Name         string
}

// Retrieves basic task references for all tasks in a project
func (q *Queries) GetTaskReferencesForProject(ctx context.Context, id int64) ([]GetTaskReferencesForProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskReferencesForProject, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTaskReferencesForProjectRow{}
	for rows.Next() {
		var i GetTaskReferencesForProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketNumber,
			&i.Title,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskRelationsForProject = `-- name: GetTaskRelationsForProject :many
select
    ts.parent_id,
    ts.child_id,
    rt.c_to_p_label as relation_label,
    rt.color as relation_color,
    rt.is_blocking
from task_subtasks ts
inner join relation_types rt on ts.relation_type_id = rt.id
inner join tasks t_parent on ts.parent_id = t_parent.id
inner join columns c on t_parent.column_id = c.id
where c.project_id = ?
`

type GetTaskRelationsForProjectRow struct {
	ParentID      int64
	ChildID       int64
	RelationLabel string
	RelationColor string
	IsBlocking    bool
}

// Retrieves all parent-child task relationships
// in a project for tree visualization
func (q *Queries) GetTaskRelationsForProject(ctx context.Context, projectID int64) ([]GetTaskRelationsForProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskRelationsForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTaskRelationsForProjectRow{}
	for rows.Next() {
		var i GetTaskRelationsForProjectRow
		if err := rows.Scan(
			&i.ParentID,
			&i.ChildID,
			&i.RelationLabel,
			&i.RelationColor,
			&i.IsBlocking,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskSummariesByColumn = `-- name: GetTaskSummariesByColumn :many
select
    t.id,
    t.title,
    t.column_id,
    t.position,
    ty.description as type_description,
    p.description as priority_description,
    p.color as priority_color,
    cast(coalesce(group_concat(l.id, char(31)), '') as text) as label_ids,
    cast(coalesce(group_concat(l.name, char(31)), '') as text) as label_names,
    cast(coalesce(group_concat(l.color, char(31)), '') as text) as label_colors
from tasks t
left join types ty on t.type_id = ty.id
left join priorities p on t.priority_id = p.id
left join task_labels tl on t.id = tl.task_id
left join labels l on tl.label_id = l.id
where t.column_id = ?
group by
    t.id,
    t.title,
    t.column_id,
    t.position,
    ty.description,
    p.description,
    p.color
order by t.position
`

type GetTaskSummariesByColumnRow struct {
	ID                  int64
	Title               string
	ColumnID            int64
	Position            int64
	TypeDescription     sql.NullString
	PriorityDescription sql.NullString
	PriorityColor       sql.NullString
	LabelIds            string
	LabelNames          string
	LabelColors         string
}

// Retrieves task summaries with aggregated labels for a specific column using GROUP_CONCAT to avoid N+1 queries
func (q *Queries) GetTaskSummariesByColumn(ctx context.Context, columnID int64) ([]GetTaskSummariesByColumnRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskSummariesByColumn, columnID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTaskSummariesByColumnRow{}
	for rows.Next() {
		var i GetTaskSummariesByColumnRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ColumnID,
			&i.Position,
			&i.TypeDescription,
			&i.PriorityDescription,
			&i.PriorityColor,
			&i.LabelIds,
			&i.LabelNames,
			&i.LabelColors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskSummariesByProject = `-- name: GetTaskSummariesByProject :many
select
    t.id,
    t.title,
    t.column_id,
    t.position,
    ty.description as type_description,
    p.description as priority_description,
    p.color as priority_color,
    cast(coalesce(group_concat(l.id, char(31)), '') as text) as label_ids,
    cast(coalesce(group_concat(l.name, char(31)), '') as text) as label_names,
    cast(coalesce(group_concat(l.color, char(31)), '') as text) as label_colors,
    exists(
        select 1
        from task_subtasks ts
        inner join relation_types rt on ts.relation_type_id = rt.id
        where ts.parent_id = t.id and rt.is_blocking = 1
    ) as is_blocked
from tasks t
inner join columns c on t.column_id = c.id
left join types ty on t.type_id = ty.id
left join priorities p on t.priority_id = p.id
left join task_labels tl on t.id = tl.task_id
left join labels l on tl.label_id = l.id
where c.project_id = ?
group by
    t.id,
    t.title,
    t.column_id,
    t.position,
    ty.description,
    p.description,
    p.color
order by t.position
`

type GetTaskSummariesByProjectRow struct {
	ID                  int64
	Title               string
	ColumnID            int64
	Position            int64
	TypeDescription     sql.NullString
	PriorityDescription sql.NullString
	PriorityColor       sql.NullString
	LabelIds            string
	LabelNames          string
	LabelColors         string
	IsBlocked           int64
}

// Retrieves task summaries with aggregated labels and blocking status
// for all tasks in a project
func (q *Queries) GetTaskSummariesByProject(ctx context.Context, projectID int64) ([]GetTaskSummariesByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskSummariesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTaskSummariesByProjectRow{}
	for rows.Next() {
		var i GetTaskSummariesByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ColumnID,
			&i.Position,
			&i.TypeDescription,
			&i.PriorityDescription,
			&i.PriorityColor,
			&i.LabelIds,
			&i.LabelNames,
			&i.LabelColors,
			&i.IsBlocked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskSummariesByProjectFiltered = `-- name: GetTaskSummariesByProjectFiltered :many
select
    t.id,
    t.title,
    t.column_id,
    t.position,
    ty.description as type_description,
    p.description as priority_description,
    p.color as priority_color,
    cast(coalesce(group_concat(l.id, char(31)), '') as text) as label_ids,
    cast(coalesce(group_concat(l.name, char(31)), '') as text) as label_names,
    cast(coalesce(group_concat(l.color, char(31)), '') as text) as label_colors,
    exists(
        select 1
        from task_subtasks ts
        inner join relation_types rt on ts.relation_type_id = rt.id
        where ts.parent_id = t.id and rt.is_blocking = 1
    ) as is_blocked
from tasks t
inner join columns c on t.column_id = c.id
left join types ty on t.type_id = ty.id
left join priorities p on t.priority_id = p.id
left join task_labels tl on t.id = tl.task_id
left join labels l on tl.label_id = l.id
where c.project_id = ? and t.title like ?
group by
    t.id,
    t.title,
    t.column_id,
    t.position,
    ty.description,
    p.description,
    p.color
order by t.position
`

type GetTaskSummariesByProjectFilteredParams struct {
	ProjectID int64
	Title     string
}

type GetTaskSummariesByProjectFilteredRow struct {
	ID                  int64
	Title               string
	ColumnID            int64
	Position            int64
	TypeDescription     sql.NullString
	PriorityDescription sql.NullString
	PriorityColor       sql.NullString
	LabelIds            string
	LabelNames          string
	LabelColors         string
	IsBlocked           int64
}

// Retrieves task summaries filtered by title search pattern with aggregated labels
func (q *Queries) GetTaskSummariesByProjectFiltered(ctx context.Context, arg GetTaskSummariesByProjectFilteredParams) ([]GetTaskSummariesByProjectFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskSummariesByProjectFiltered, arg.ProjectID, arg.Title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTaskSummariesByProjectFilteredRow{}
	for rows.Next() {
		var i GetTaskSummariesByProjectFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ColumnID,
			&i.Position,
			&i.TypeDescription,
			&i.PriorityDescription,
			&i.PriorityColor,
			&i.LabelIds,
			&i.LabelNames,
			&i.LabelColors,
			&i.IsBlocked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksByColumn = `-- name: GetTasksByColumn :many
select
    id,
    title,
    description,
    column_id,
    position,
    created_at,
    updated_at
from tasks
where column_id = ?
order by position
`

type GetTasksByColumnRow struct {
	ID          int64
	Title       string
	Description sql.NullString
	ColumnID    int64
	Position    int64
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

// Retrieves all tasks in a column, ordered by position
func (q *Queries) GetTasksByColumn(ctx context.Context, columnID int64) ([]GetTasksByColumnRow, error) {
	rows, err := q.db.QueryContext(ctx, getTasksByColumn, columnID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTasksByColumnRow{}
	for rows.Next() {
		var i GetTasksByColumnRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ColumnID,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksForTree = `-- name: GetTasksForTree :many
select
    t.id,
    t.ticket_number,
    t.title,
    c.name as column_name,
    proj.name as project_name
from tasks t
inner join columns c on t.column_id = c.id
inner join projects proj on c.project_id = proj.id
where proj.id = ?
order by t.ticket_number
`

type GetTasksForTreeRow struct {
	ID           int64
	TicketNumber sql.NullInt64
	Title        string
	ColumnName   string
	ProjectName  string
}

// Retrieves all tasks in a project with column
// and project names for tree visualization
func (q *Queries) GetTasksForTree(ctx context.Context, id int64) ([]GetTasksForTreeRow, error) {
	rows, err := q.db.QueryContext(ctx, getTasksForTree, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTasksForTreeRow{}
	for rows.Next() {
		var i GetTasksForTreeRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketNumber,
			&i.Title,
			&i.ColumnName,
			&i.ProjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementTicketNumber = `-- name: IncrementTicketNumber :exec
update project_counters
set next_ticket_number = next_ticket_number + 1
where project_id = ?
`

// Increments the ticket counter for a project after assigning a ticket number
func (q *Queries) IncrementTicketNumber(ctx context.Context, projectID int64) error {
	_, err := q.db.ExecContext(ctx, incrementTicketNumber, projectID)
	return err
}

const moveTaskToColumn = `-- name: MoveTaskToColumn :exec
update tasks
set column_id = ?,
    position = ?,
    updated_at = current_timestamp
where id = ?
`

type MoveTaskToColumnParams struct {
	ColumnID int64
	Position int64
	ID       int64
}

// Moves a task to a different column and updates its position
func (q *Queries) MoveTaskToColumn(ctx context.Context, arg MoveTaskToColumnParams) error {
	_, err := q.db.ExecContext(ctx, moveTaskToColumn, arg.ColumnID, arg.Position, arg.ID)
	return err
}

const removeSubtask = `-- name: RemoveSubtask :exec
delete from task_subtasks where parent_id = ? and child_id = ?
`

type RemoveSubtaskParams struct {
	ParentID int64
	ChildID  int64
}

// Removes a parent-child relationship between two tasks
func (q *Queries) RemoveSubtask(ctx context.Context, arg RemoveSubtaskParams) error {
	_, err := q.db.ExecContext(ctx, removeSubtask, arg.ParentID, arg.ChildID)
	return err
}

const setTaskPosition = `-- name: SetTaskPosition :exec
update tasks
set position = ?,
updated_at = current_timestamp
where id = ?
`

type SetTaskPositionParams struct {
	Position int64
	ID       int64
}

// Updates a task's position within its current column
func (q *Queries) SetTaskPosition(ctx context.Context, arg SetTaskPositionParams) error {
	_, err := q.db.ExecContext(ctx, setTaskPosition, arg.Position, arg.ID)
	return err
}

const setTaskPositionTemporary = `-- name: SetTaskPositionTemporary :exec
update tasks 
set position = -1,
updated_at = current_timestamp
where id = ?
`

// Sets task position to -1 temporarily during reordering operations
func (q *Queries) SetTaskPositionTemporary(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, setTaskPositionTemporary, id)
	return err
}

const updateTask = `-- name: UpdateTask :exec
update tasks
set title = ?, description = ?, updated_at = current_timestamp
where id = ?
`

type UpdateTaskParams struct {
	Title       string
	Description sql.NullString
	ID          int64
}

// Updates a task's title and description
func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.ExecContext(ctx, updateTask, arg.Title, arg.Description, arg.ID)
	return err
}

const updateTaskPriority = `-- name: UpdateTaskPriority :exec
update tasks
set priority_id = ?, updated_at = current_timestamp
where id = ?
`

type UpdateTaskPriorityParams struct {
	PriorityID int64
	ID         int64
}

// Updates a task's priority level
func (q *Queries) UpdateTaskPriority(ctx context.Context, arg UpdateTaskPriorityParams) error {
	_, err := q.db.ExecContext(ctx, updateTaskPriority, arg.PriorityID, arg.ID)
	return err
}

const updateTaskType = `-- name: UpdateTaskType :exec
update tasks
set type_id = ?, updated_at = current_timestamp
where id = ?
`

type UpdateTaskTypeParams struct {
	TypeID int64
	ID     int64
}

// Updates a task's type classification
func (q *Queries) UpdateTaskType(ctx context.Context, arg UpdateTaskTypeParams) error {
	_, err := q.db.ExecContext(ctx, updateTaskType, arg.TypeID, arg.ID)
	return err
}
