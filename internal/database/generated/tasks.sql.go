// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tasks.sql

package generated

import (
	"context"
	"database/sql"
)

const addSubtask = `-- name: AddSubtask :exec
INSERT OR IGNORE INTO task_subtasks (parent_id, child_id) VALUES (?, ?)
`

type AddSubtaskParams struct {
	ParentID int64
	ChildID  int64
}

func (q *Queries) AddSubtask(ctx context.Context, arg AddSubtaskParams) error {
	_, err := q.db.ExecContext(ctx, addSubtask, arg.ParentID, arg.ChildID)
	return err
}

const addSubtaskWithRelationType = `-- name: AddSubtaskWithRelationType :exec
INSERT OR REPLACE INTO task_subtasks (parent_id, child_id, relation_type_id)
VALUES (?, ?, ?)
`

type AddSubtaskWithRelationTypeParams struct {
	ParentID       int64
	ChildID        int64
	RelationTypeID int64
}

func (q *Queries) AddSubtaskWithRelationType(ctx context.Context, arg AddSubtaskWithRelationTypeParams) error {
	_, err := q.db.ExecContext(ctx, addSubtaskWithRelationType, arg.ParentID, arg.ChildID, arg.RelationTypeID)
	return err
}

const createTask = `-- name: CreateTask :one

INSERT INTO tasks (title, description, column_id, position, ticket_number)
VALUES (?, ?, ?, ?, ?)
RETURNING id, title, description, column_id, position, ticket_number, type_id, priority_id, created_at, updated_at
`

type CreateTaskParams struct {
	Title        string
	Description  sql.NullString
	ColumnID     int64
	Position     int64
	TicketNumber sql.NullInt64
}

// ============================================================================
// TASK CRUD OPERATIONS
// ============================================================================
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.Title,
		arg.Description,
		arg.ColumnID,
		arg.Position,
		arg.TicketNumber,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ColumnID,
		&i.Position,
		&i.TicketNumber,
		&i.TypeID,
		&i.PriorityID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE id = ?
`

func (q *Queries) DeleteTask(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTask, id)
	return err
}

const getAllPriorities = `-- name: GetAllPriorities :many

SELECT id, description, color FROM priorities ORDER BY id
`

// ============================================================================
// PRIORITIES AND TYPES
// ============================================================================
func (q *Queries) GetAllPriorities(ctx context.Context) ([]Priority, error) {
	rows, err := q.db.QueryContext(ctx, getAllPriorities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Priority{}
	for rows.Next() {
		var i Priority
		if err := rows.Scan(&i.ID, &i.Description, &i.Color); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRelationTypes = `-- name: GetAllRelationTypes :many
SELECT id, p_to_c_label, c_to_p_label, color, is_blocking
FROM relation_types
ORDER BY id
`

func (q *Queries) GetAllRelationTypes(ctx context.Context) ([]RelationType, error) {
	rows, err := q.db.QueryContext(ctx, getAllRelationTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RelationType{}
	for rows.Next() {
		var i RelationType
		if err := rows.Scan(
			&i.ID,
			&i.PToCLabel,
			&i.CToPLabel,
			&i.Color,
			&i.IsBlocking,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTypes = `-- name: GetAllTypes :many
SELECT id, description FROM types ORDER BY id
`

func (q *Queries) GetAllTypes(ctx context.Context) ([]Type, error) {
	rows, err := q.db.QueryContext(ctx, getAllTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Type{}
	for rows.Next() {
		var i Type
		if err := rows.Scan(&i.ID, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChildTasks = `-- name: GetChildTasks :many
SELECT t.id, t.ticket_number, t.title, p.name,
       rt.id, rt.c_to_p_label, rt.color, rt.is_blocking
FROM tasks t
INNER JOIN task_subtasks ts ON t.id = ts.child_id
INNER JOIN relation_types rt ON ts.relation_type_id = rt.id
INNER JOIN columns c ON t.column_id = c.id
INNER JOIN projects p ON c.project_id = p.id
WHERE ts.parent_id = ?
ORDER BY p.name, t.ticket_number
`

type GetChildTasksRow struct {
	ID           int64
	TicketNumber sql.NullInt64
	Title        string
	Name         string
	ID_2         int64
	CToPLabel    string
	Color        string
	IsBlocking   bool
}

func (q *Queries) GetChildTasks(ctx context.Context, parentID int64) ([]GetChildTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, getChildTasks, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChildTasksRow{}
	for rows.Next() {
		var i GetChildTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketNumber,
			&i.Title,
			&i.Name,
			&i.ID_2,
			&i.CToPLabel,
			&i.Color,
			&i.IsBlocking,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNextColumnID = `-- name: GetNextColumnID :one
SELECT next_id FROM columns WHERE id = ?
`

func (q *Queries) GetNextColumnID(ctx context.Context, id int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getNextColumnID, id)
	var next_id interface{}
	err := row.Scan(&next_id)
	return next_id, err
}

const getNextTicketNumber = `-- name: GetNextTicketNumber :one

SELECT next_ticket_number FROM project_counters WHERE project_id = ?
`

// ============================================================================
// TICKET NUMBER MANAGEMENT
// ============================================================================
func (q *Queries) GetNextTicketNumber(ctx context.Context, projectID int64) (sql.NullInt64, error) {
	row := q.db.QueryRowContext(ctx, getNextTicketNumber, projectID)
	var next_ticket_number sql.NullInt64
	err := row.Scan(&next_ticket_number)
	return next_ticket_number, err
}

const getParentTasks = `-- name: GetParentTasks :many

SELECT t.id, t.ticket_number, t.title, p.name,
       rt.id, rt.p_to_c_label, rt.color, rt.is_blocking
FROM tasks t
INNER JOIN task_subtasks ts ON t.id = ts.parent_id
INNER JOIN relation_types rt ON ts.relation_type_id = rt.id
INNER JOIN columns c ON t.column_id = c.id
INNER JOIN projects p ON c.project_id = p.id
WHERE ts.child_id = ?
ORDER BY p.name, t.ticket_number
`

type GetParentTasksRow struct {
	ID           int64
	TicketNumber sql.NullInt64
	Title        string
	Name         string
	ID_2         int64
	PToCLabel    string
	Color        string
	IsBlocking   bool
}

// ============================================================================
// TASK RELATIONSHIPS (Subtasks, Parents, Blockers)
// ============================================================================
func (q *Queries) GetParentTasks(ctx context.Context, childID int64) ([]GetParentTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, getParentTasks, childID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetParentTasksRow{}
	for rows.Next() {
		var i GetParentTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketNumber,
			&i.Title,
			&i.Name,
			&i.ID_2,
			&i.PToCLabel,
			&i.Color,
			&i.IsBlocking,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrevColumnID = `-- name: GetPrevColumnID :one
SELECT prev_id FROM columns WHERE id = ?
`

func (q *Queries) GetPrevColumnID(ctx context.Context, id int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getPrevColumnID, id)
	var prev_id interface{}
	err := row.Scan(&prev_id)
	return prev_id, err
}

const getProjectIDFromColumn = `-- name: GetProjectIDFromColumn :one
SELECT project_id FROM columns WHERE id = ?
`

func (q *Queries) GetProjectIDFromColumn(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getProjectIDFromColumn, id)
	var project_id int64
	err := row.Scan(&project_id)
	return project_id, err
}

const getProjectIDFromTask = `-- name: GetProjectIDFromTask :one

SELECT c.project_id FROM tasks t
INNER JOIN columns c ON t.column_id = c.id
WHERE t.id = ?
`

// ============================================================================
// PROJECT HELPERS (for event notifications)
// ============================================================================
func (q *Queries) GetProjectIDFromTask(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getProjectIDFromTask, id)
	var project_id int64
	err := row.Scan(&project_id)
	return project_id, err
}

const getReadyTaskSummariesByProject = `-- name: GetReadyTaskSummariesByProject :many
SELECT
    t.id,
    t.title,
    t.column_id,
    t.position,
    ty.description as type_description,
    p.description as priority_description,
    p.color as priority_color,
    CAST(COALESCE(GROUP_CONCAT(l.id, CHAR(31)), '') AS TEXT) as label_ids,
    CAST(COALESCE(GROUP_CONCAT(l.name, CHAR(31)), '') AS TEXT) as label_names,
    CAST(COALESCE(GROUP_CONCAT(l.color, CHAR(31)), '') AS TEXT) as label_colors,
    EXISTS(
        SELECT 1 FROM task_subtasks ts
        INNER JOIN relation_types rt ON ts.relation_type_id = rt.id
        WHERE ts.parent_id = t.id AND rt.is_blocking = 1
    ) as is_blocked
FROM tasks t
INNER JOIN columns c ON t.column_id = c.id
LEFT JOIN types ty ON t.type_id = ty.id
LEFT JOIN priorities p ON t.priority_id = p.id
LEFT JOIN task_labels tl ON t.id = tl.task_id
LEFT JOIN labels l ON tl.label_id = l.id
WHERE c.project_id = ? AND c.holds_ready_tasks = 1
GROUP BY t.id, t.title, t.column_id, t.position, ty.description, p.description, p.color
ORDER BY t.position
`

type GetReadyTaskSummariesByProjectRow struct {
	ID                  int64
	Title               string
	ColumnID            int64
	Position            int64
	TypeDescription     sql.NullString
	PriorityDescription sql.NullString
	PriorityColor       sql.NullString
	LabelIds            string
	LabelNames          string
	LabelColors         string
	IsBlocked           int64
}

func (q *Queries) GetReadyTaskSummariesByProject(ctx context.Context, projectID int64) ([]GetReadyTaskSummariesByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getReadyTaskSummariesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReadyTaskSummariesByProjectRow{}
	for rows.Next() {
		var i GetReadyTaskSummariesByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ColumnID,
			&i.Position,
			&i.TypeDescription,
			&i.PriorityDescription,
			&i.PriorityColor,
			&i.LabelIds,
			&i.LabelNames,
			&i.LabelColors,
			&i.IsBlocked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTask = `-- name: GetTask :one
SELECT id, title, description, column_id, position, created_at, updated_at
FROM tasks
WHERE id = ?
`

type GetTaskRow struct {
	ID          int64
	Title       string
	Description sql.NullString
	ColumnID    int64
	Position    int64
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetTask(ctx context.Context, id int64) (GetTaskRow, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i GetTaskRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ColumnID,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTaskAbove = `-- name: GetTaskAbove :one
SELECT id, position FROM tasks
WHERE column_id = ? AND position < ?
ORDER BY position DESC LIMIT 1
`

type GetTaskAboveParams struct {
	ColumnID int64
	Position int64
}

type GetTaskAboveRow struct {
	ID       int64
	Position int64
}

func (q *Queries) GetTaskAbove(ctx context.Context, arg GetTaskAboveParams) (GetTaskAboveRow, error) {
	row := q.db.QueryRowContext(ctx, getTaskAbove, arg.ColumnID, arg.Position)
	var i GetTaskAboveRow
	err := row.Scan(&i.ID, &i.Position)
	return i, err
}

const getTaskBelow = `-- name: GetTaskBelow :one
SELECT id, position FROM tasks
WHERE column_id = ? AND position > ?
ORDER BY position ASC LIMIT 1
`

type GetTaskBelowParams struct {
	ColumnID int64
	Position int64
}

type GetTaskBelowRow struct {
	ID       int64
	Position int64
}

func (q *Queries) GetTaskBelow(ctx context.Context, arg GetTaskBelowParams) (GetTaskBelowRow, error) {
	row := q.db.QueryRowContext(ctx, getTaskBelow, arg.ColumnID, arg.Position)
	var i GetTaskBelowRow
	err := row.Scan(&i.ID, &i.Position)
	return i, err
}

const getTaskCountByColumn = `-- name: GetTaskCountByColumn :one
SELECT COUNT(*) FROM tasks WHERE column_id = ?
`

func (q *Queries) GetTaskCountByColumn(ctx context.Context, columnID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTaskCountByColumn, columnID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTaskDetail = `-- name: GetTaskDetail :one

SELECT t.id, t.title, t.description, t.column_id, t.position,
       t.ticket_number, t.created_at, t.updated_at,
       ty.description as type_description,
       p.description as priority_description,
       p.color as priority_color,
       c.name as column_name,
       proj.name as project_name,
       EXISTS(
           SELECT 1 FROM task_subtasks ts
           INNER JOIN relation_types rt ON ts.relation_type_id = rt.id
           WHERE ts.parent_id = t.id AND rt.is_blocking = 1
       ) as is_blocked
FROM tasks t
INNER JOIN columns c ON t.column_id = c.id
INNER JOIN projects proj ON c.project_id = proj.id
LEFT JOIN types ty ON t.type_id = ty.id
LEFT JOIN priorities p ON t.priority_id = p.id
WHERE t.id = ?
`

type GetTaskDetailRow struct {
	ID                  int64
	Title               string
	Description         sql.NullString
	ColumnID            int64
	Position            int64
	TicketNumber        sql.NullInt64
	CreatedAt           sql.NullTime
	UpdatedAt           sql.NullTime
	TypeDescription     sql.NullString
	PriorityDescription sql.NullString
	PriorityColor       sql.NullString
	ColumnName          string
	ProjectName         string
	IsBlocked           int64
}

// ============================================================================
// TASK DETAIL QUERIES
// ============================================================================
func (q *Queries) GetTaskDetail(ctx context.Context, id int64) (GetTaskDetailRow, error) {
	row := q.db.QueryRowContext(ctx, getTaskDetail, id)
	var i GetTaskDetailRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ColumnID,
		&i.Position,
		&i.TicketNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TypeDescription,
		&i.PriorityDescription,
		&i.PriorityColor,
		&i.ColumnName,
		&i.ProjectName,
		&i.IsBlocked,
	)
	return i, err
}

const getTaskLabels = `-- name: GetTaskLabels :many
SELECT l.id, l.name, l.color, l.project_id
FROM labels l
INNER JOIN task_labels tl ON l.id = tl.label_id
WHERE tl.task_id = ?
ORDER BY l.name
`

func (q *Queries) GetTaskLabels(ctx context.Context, taskID int64) ([]Label, error) {
	rows, err := q.db.QueryContext(ctx, getTaskLabels, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Label{}
	for rows.Next() {
		var i Label
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Color,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskPosition = `-- name: GetTaskPosition :one

SELECT column_id, position FROM tasks WHERE id = ?
`

type GetTaskPositionRow struct {
	ColumnID int64
	Position int64
}

// ============================================================================
// TASK MOVEMENT OPERATIONS
// ============================================================================
func (q *Queries) GetTaskPosition(ctx context.Context, id int64) (GetTaskPositionRow, error) {
	row := q.db.QueryRowContext(ctx, getTaskPosition, id)
	var i GetTaskPositionRow
	err := row.Scan(&i.ColumnID, &i.Position)
	return i, err
}

const getTaskReferencesForProject = `-- name: GetTaskReferencesForProject :many
SELECT t.id, t.ticket_number, t.title, p.name
FROM tasks t
INNER JOIN columns c ON t.column_id = c.id
INNER JOIN projects p ON c.project_id = p.id
WHERE p.id = ?
ORDER BY p.name, t.ticket_number
`

type GetTaskReferencesForProjectRow struct {
	ID           int64
	TicketNumber sql.NullInt64
	Title        string
	Name         string
}

func (q *Queries) GetTaskReferencesForProject(ctx context.Context, id int64) ([]GetTaskReferencesForProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskReferencesForProject, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTaskReferencesForProjectRow{}
	for rows.Next() {
		var i GetTaskReferencesForProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketNumber,
			&i.Title,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskSummariesByColumn = `-- name: GetTaskSummariesByColumn :many

SELECT
    t.id,
    t.title,
    t.column_id,
    t.position,
    ty.description as type_description,
    p.description as priority_description,
    p.color as priority_color,
    CAST(COALESCE(GROUP_CONCAT(l.id, CHAR(31)), '') AS TEXT) as label_ids,
    CAST(COALESCE(GROUP_CONCAT(l.name, CHAR(31)), '') AS TEXT) as label_names,
    CAST(COALESCE(GROUP_CONCAT(l.color, CHAR(31)), '') AS TEXT) as label_colors
FROM tasks t
LEFT JOIN types ty ON t.type_id = ty.id
LEFT JOIN priorities p ON t.priority_id = p.id
LEFT JOIN task_labels tl ON t.id = tl.task_id
LEFT JOIN labels l ON tl.label_id = l.id
WHERE t.column_id = ?
GROUP BY t.id, t.title, t.column_id, t.position, ty.description, p.description, p.color
ORDER BY t.position
`

type GetTaskSummariesByColumnRow struct {
	ID                  int64
	Title               string
	ColumnID            int64
	Position            int64
	TypeDescription     sql.NullString
	PriorityDescription sql.NullString
	PriorityColor       sql.NullString
	LabelIds            string
	LabelNames          string
	LabelColors         string
}

// ============================================================================
// TASK SUMMARIES (Optimized with JOINs to avoid N+1 queries)
// ============================================================================
func (q *Queries) GetTaskSummariesByColumn(ctx context.Context, columnID int64) ([]GetTaskSummariesByColumnRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskSummariesByColumn, columnID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTaskSummariesByColumnRow{}
	for rows.Next() {
		var i GetTaskSummariesByColumnRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ColumnID,
			&i.Position,
			&i.TypeDescription,
			&i.PriorityDescription,
			&i.PriorityColor,
			&i.LabelIds,
			&i.LabelNames,
			&i.LabelColors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskSummariesByProject = `-- name: GetTaskSummariesByProject :many
SELECT
    t.id,
    t.title,
    t.column_id,
    t.position,
    ty.description as type_description,
    p.description as priority_description,
    p.color as priority_color,
    CAST(COALESCE(GROUP_CONCAT(l.id, CHAR(31)), '') AS TEXT) as label_ids,
    CAST(COALESCE(GROUP_CONCAT(l.name, CHAR(31)), '') AS TEXT) as label_names,
    CAST(COALESCE(GROUP_CONCAT(l.color, CHAR(31)), '') AS TEXT) as label_colors,
    EXISTS(
        SELECT 1 FROM task_subtasks ts
        INNER JOIN relation_types rt ON ts.relation_type_id = rt.id
        WHERE ts.parent_id = t.id AND rt.is_blocking = 1
    ) as is_blocked
FROM tasks t
INNER JOIN columns c ON t.column_id = c.id
LEFT JOIN types ty ON t.type_id = ty.id
LEFT JOIN priorities p ON t.priority_id = p.id
LEFT JOIN task_labels tl ON t.id = tl.task_id
LEFT JOIN labels l ON tl.label_id = l.id
WHERE c.project_id = ?
GROUP BY t.id, t.title, t.column_id, t.position, ty.description, p.description, p.color
ORDER BY t.position
`

type GetTaskSummariesByProjectRow struct {
	ID                  int64
	Title               string
	ColumnID            int64
	Position            int64
	TypeDescription     sql.NullString
	PriorityDescription sql.NullString
	PriorityColor       sql.NullString
	LabelIds            string
	LabelNames          string
	LabelColors         string
	IsBlocked           int64
}

func (q *Queries) GetTaskSummariesByProject(ctx context.Context, projectID int64) ([]GetTaskSummariesByProjectRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskSummariesByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTaskSummariesByProjectRow{}
	for rows.Next() {
		var i GetTaskSummariesByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ColumnID,
			&i.Position,
			&i.TypeDescription,
			&i.PriorityDescription,
			&i.PriorityColor,
			&i.LabelIds,
			&i.LabelNames,
			&i.LabelColors,
			&i.IsBlocked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskSummariesByProjectFiltered = `-- name: GetTaskSummariesByProjectFiltered :many
SELECT
    t.id,
    t.title,
    t.column_id,
    t.position,
    ty.description as type_description,
    p.description as priority_description,
    p.color as priority_color,
    CAST(COALESCE(GROUP_CONCAT(l.id, CHAR(31)), '') AS TEXT) as label_ids,
    CAST(COALESCE(GROUP_CONCAT(l.name, CHAR(31)), '') AS TEXT) as label_names,
    CAST(COALESCE(GROUP_CONCAT(l.color, CHAR(31)), '') AS TEXT) as label_colors,
    EXISTS(
        SELECT 1 FROM task_subtasks ts
        INNER JOIN relation_types rt ON ts.relation_type_id = rt.id
        WHERE ts.parent_id = t.id AND rt.is_blocking = 1
    ) as is_blocked
FROM tasks t
INNER JOIN columns c ON t.column_id = c.id
LEFT JOIN types ty ON t.type_id = ty.id
LEFT JOIN priorities p ON t.priority_id = p.id
LEFT JOIN task_labels tl ON t.id = tl.task_id
LEFT JOIN labels l ON tl.label_id = l.id
WHERE c.project_id = ? AND t.title LIKE ?
GROUP BY t.id, t.title, t.column_id, t.position, ty.description, p.description, p.color
ORDER BY t.position
`

type GetTaskSummariesByProjectFilteredParams struct {
	ProjectID int64
	Title     string
}

type GetTaskSummariesByProjectFilteredRow struct {
	ID                  int64
	Title               string
	ColumnID            int64
	Position            int64
	TypeDescription     sql.NullString
	PriorityDescription sql.NullString
	PriorityColor       sql.NullString
	LabelIds            string
	LabelNames          string
	LabelColors         string
	IsBlocked           int64
}

func (q *Queries) GetTaskSummariesByProjectFiltered(ctx context.Context, arg GetTaskSummariesByProjectFilteredParams) ([]GetTaskSummariesByProjectFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, getTaskSummariesByProjectFiltered, arg.ProjectID, arg.Title)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTaskSummariesByProjectFilteredRow{}
	for rows.Next() {
		var i GetTaskSummariesByProjectFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ColumnID,
			&i.Position,
			&i.TypeDescription,
			&i.PriorityDescription,
			&i.PriorityColor,
			&i.LabelIds,
			&i.LabelNames,
			&i.LabelColors,
			&i.IsBlocked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksByColumn = `-- name: GetTasksByColumn :many
SELECT id, title, description, column_id, position, created_at, updated_at
FROM tasks
WHERE column_id = ?
ORDER BY position
`

type GetTasksByColumnRow struct {
	ID          int64
	Title       string
	Description sql.NullString
	ColumnID    int64
	Position    int64
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetTasksByColumn(ctx context.Context, columnID int64) ([]GetTasksByColumnRow, error) {
	rows, err := q.db.QueryContext(ctx, getTasksByColumn, columnID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTasksByColumnRow{}
	for rows.Next() {
		var i GetTasksByColumnRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ColumnID,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementTicketNumber = `-- name: IncrementTicketNumber :exec
UPDATE project_counters SET next_ticket_number = next_ticket_number + 1 WHERE project_id = ?
`

func (q *Queries) IncrementTicketNumber(ctx context.Context, projectID int64) error {
	_, err := q.db.ExecContext(ctx, incrementTicketNumber, projectID)
	return err
}

const moveTaskToColumn = `-- name: MoveTaskToColumn :exec
UPDATE tasks
SET column_id = ?, position = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type MoveTaskToColumnParams struct {
	ColumnID int64
	Position int64
	ID       int64
}

func (q *Queries) MoveTaskToColumn(ctx context.Context, arg MoveTaskToColumnParams) error {
	_, err := q.db.ExecContext(ctx, moveTaskToColumn, arg.ColumnID, arg.Position, arg.ID)
	return err
}

const removeSubtask = `-- name: RemoveSubtask :exec
DELETE FROM task_subtasks WHERE parent_id = ? AND child_id = ?
`

type RemoveSubtaskParams struct {
	ParentID int64
	ChildID  int64
}

func (q *Queries) RemoveSubtask(ctx context.Context, arg RemoveSubtaskParams) error {
	_, err := q.db.ExecContext(ctx, removeSubtask, arg.ParentID, arg.ChildID)
	return err
}

const setTaskPosition = `-- name: SetTaskPosition :exec
UPDATE tasks
SET position = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type SetTaskPositionParams struct {
	Position int64
	ID       int64
}

func (q *Queries) SetTaskPosition(ctx context.Context, arg SetTaskPositionParams) error {
	_, err := q.db.ExecContext(ctx, setTaskPosition, arg.Position, arg.ID)
	return err
}

const setTaskPositionTemporary = `-- name: SetTaskPositionTemporary :exec
UPDATE tasks SET position = -1, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) SetTaskPositionTemporary(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, setTaskPositionTemporary, id)
	return err
}

const updateTask = `-- name: UpdateTask :exec
UPDATE tasks
SET title = ?, description = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateTaskParams struct {
	Title       string
	Description sql.NullString
	ID          int64
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.ExecContext(ctx, updateTask, arg.Title, arg.Description, arg.ID)
	return err
}

const updateTaskPriority = `-- name: UpdateTaskPriority :exec
UPDATE tasks
SET priority_id = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateTaskPriorityParams struct {
	PriorityID int64
	ID         int64
}

func (q *Queries) UpdateTaskPriority(ctx context.Context, arg UpdateTaskPriorityParams) error {
	_, err := q.db.ExecContext(ctx, updateTaskPriority, arg.PriorityID, arg.ID)
	return err
}

const updateTaskType = `-- name: UpdateTaskType :exec
UPDATE tasks
SET type_id = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateTaskTypeParams struct {
	TypeID int64
	ID     int64
}

func (q *Queries) UpdateTaskType(ctx context.Context, arg UpdateTaskTypeParams) error {
	_, err := q.db.ExecContext(ctx, updateTaskType, arg.TypeID, arg.ID)
	return err
}
